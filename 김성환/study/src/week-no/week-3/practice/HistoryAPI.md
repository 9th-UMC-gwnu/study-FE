## History API

### 이거 왜 배움?
- 예상치 못한 문제 상황에 유연한 대응이 가능하다.
- 서비스에 맞게 커스터마이징하여 더 나은 UX를 줄 수 있다.
- 내부 동작 원리를 이해하는 습관은 결국 더 단단한 개발 실력을 만들어 준다는 점을 생각하자

### 과거의 웹
링크를 클릭하면 브라우저는 새로운 URL로 요청을 보내고, 서버가 새로운 HTML을 내려주면 화면 전체가 리렌더링 되는 방식 이었다.(문서 <-> 문서 링크 연결 구조)
하지만, 이런 방식을 사용하면 아래와 같은 단점이 생긴다.

- 매번 새 문서를 받아오니 속도가 느리고
- 동일한 리소스를 반복적으로 로드
- 화면 전환이 매끄럽지 않았다.

이를 해결하기 위해 HTML5에서 History API가 등장했다. 주소창의 URL은 바뀌되, 전체 리로드는 막고 필요한 부분만 교체하는 애플리케이션화를 진행하였다.

### pushState와 History Stack
history.pushState는 브라우저의 히스토리 스택(history stack)에 새로운 상태를 쌓는 동작이다. 주소창은 바뀌지만, 네트워크 요청은 발생하지 않는다.

1. 초기 상태
```
| /matthew | <- 현재
```

2. pushState('/aeong') 호출
```
| /aeong | <- 현재
| /matthew |
```

3. pushState('/joy') 호출
```
| /joy | <- 현재
| /aeong | 
| /matthew |
```

4. 뒤로가기 클릭 -> popState 이벤트 발생
```
| /joy |
| /aeong | <- 현재
| /matthew |
```

즉, pushState는 새로운 경로를 스택에 추가하고, 뒤로가기 / 앞으로가기 (popState 이벤트) 시에는 스택 항목이 사라지는 게 아니라 포인터만 이동한다.

## SPA 라우팅의 실제 동작 흐름

사실 SPA 라우팅은 단순한 트릭이다.

- 링크 클릭 시 
    1. 원래 서버에 요청하려는 동작을 preventDefault()로 막는다. (브라우저의 기본 동작을 막는 method)
    2. history.pushState()로 주소창만 변경한다.
    3. "경로가 바뀜" 신호를 커스텀 이베늩로 앱에 전달
- 뒤로가기 / 앞으로 가기 시
    1. 브라우저가 자동으로 URL을 바꾼다.
    2. popState 이벤트가 발생한다.
    3. 이 이벤트를 감지해 화면을 교체

**결론** : 겉보기에는 여러 HTML 페이지를 오가는 것 같지만, 실제로는 한 페이지에서 주소와 컴포넌트만 바뀌는 것 (빠르고 부드러운 전환 가능)

