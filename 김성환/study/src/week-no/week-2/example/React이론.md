## React의 동작원리

### SPA(Single Page Application)란?
- 한 번 로드한 문서 안에서 화면을 갈아끼우며 동작하는 웹 앱을 말해요. 페이지 이동 때마다 전체 HTML을 다시 받지 않고, 자바스크립트가 필요한 부분만 갈아끼워서 빠르게 반응해요.
- 장점: 화면 전환이 빠르고, 앱처럼 자연스럽게 동작해요.
- 주의점: 첫 로드가 다소 무거울 수 있고, SEO(검색 노출)엔 별도 대비가 필요해요. 그래서 SSR/SSG(서버 사이드 렌더링/정적 생성) 같은 방식과 함께 쓰는 경우가 많아요.
- React는 SPA를 만들 때 뷰를 그리는 역할(UI Library) 을 담당하고, 라우팅은 react-router 같은 별도 라이브러리를 함께 써요.

### React는 '프레임 워크'가 아닌 'UI 라이브러리'임
- React는 화면(컴포넌트) 만 책임지는 작고 단단한 도구에요.
- 라우팅, 전역 상태, 데이터 패칭, 빌드/배포 등은 **원하는 도구를 조합**해서 쓰는 문화에요.
    - 예: 라우팅 `react-router`, 상태관리 `zustand`/`Redux`, 번들러 `Vite` 등등이요.
- 덕분에 **유연성**이 높고, **프로젝트 성격에 가장 맞는 스택**을 골라 붙일 수 있어요.

### **함수형 컴포넌트**와 **상태/속성의** 흐름 이해
- **함수형 컴포넌트**는 말 그대로 “함수”에요. **입력(props)** 을 받아 **출력(JSX)** 을 반환해요.
- **상태(state)** 는 컴포넌트가 **기억해야 하는 값**이에요. `useState`로 만들고, **setter로 바꾸면 리렌더링을 트리거**해요.
- **속성(props)** 은 **부모→자식으로 내려오는 읽기 전용 데이터**예요. 자식은 props를 수정하지 않아요.
- **언제 리렌더링되나요?**
    - 내 state가 바뀔 때, 부모가 리렌더링되며 **새 props를 줄 때**, 구독한 **Context 값이 바뀔 때**, 또는 **key가 바뀔 때(완전 교체)** **리렌더링** 되요.
- **불필요한 리렌더 줄이기**
    - `React.memo`(컴포넌트 메모), `useMemo`(값 메모), `useCallback`(함수 메모)로 **동일 입력 → 동일 출력**이면 건너뛰게 만들 수 있어요.
    - 단, 조기 최적화는 금물이고, **측정 후 필요한 곳에만** 적용하는 게 좋아요.
    - 추가! : 최적화(메모이제이션)는 해당 요소의 주소를 기억해놔서 리렌더링을 방지하는 방식인데 변경 전후로 기능 동작을 보장하고 싶을 때 사용하면 된다. props 불변성에 초점을 맞춰 코드를 변경하기 때문에 렌더링 범위를 수정하는 작업보다 기능이 고장날 확률이 적다.
    - 그럼 렌더링 범위를 범위를 좁히는 방식은 어떻게 사용할까? 
        - **컴포넌트**와 **상태** 를 세분화 하여 여러 영역이 독립적으로 갱신되도록 분리한다.
        - 결론 : 메모이제이션은 "얼마나 싸게 다시 그릴까?"에 비유가 가능하고 렌더링 범위 제한은 "아예 다시 안 그리게 할 수 있나"에 비유할 수 있다. -> 둘을 같이 사용해야 체감 성능이 올라간다.

### Virtual DOM과 Diff(재조정) 원리
- **Virtual DOM**은 “화면의 설계도(스냅샷)”예요. 상태가 바뀌면 React가 **이전 설계도와 새 설계도를 비교(diff)** 해서 **바뀐 부분만 실제 DOM에 반영**해요.
- 그래서 매번 전체를 갈아엎지 않고 **필요한 최소 조각만 업데이트**하니 빠르고 일관성 있게 동작해요.
- **리스트 렌더링 시 `key`가 중요한 이유**
    - key는 **요소의 신분증**이에요. key가 안정적이면 React가 **이전/다음 항목을 정확히 매칭**해서 최소 변경만 해요.
    - 배열 인덱스를 key로 쓰면 **중간 삽입/삭제 때 오매칭**이 벌어질 수 있어, **고유한 id**를 권장해요.

### 동시성 렌더링(Concurrent Rendering)으로 “부드럽게” 렌더
- React 18부터 도입된 기능으로, 렌더링을 **작업 우선순위에 따라 쪼개어 처리**해요.
    - 예: 대용량 목록 계산보다 **사용자 입력 반응**을 먼저 처리해요.
- **`startTransition` / `useTransition`**
    - 급하지 않은 상태 업데이트를 **전환(transition)** 으로 표시하면, React가 **사용자 입력을 우선 처리**하고 전환 작업은 여유 있게 처리해요.
- **Suspense**
    - 컴포넌트가 데이터 로딩 등으로 “잠시 멈춤”이 필요하면 **대체 UI(fallback)** 를 잠깐 보여줘요.
    - **React 19 변경점**: 어떤 컴포넌트가 “suspend”되면 **가까운 Suspense의 fallback을 더 빨리 커밋**하고, 그 뒤에 멈춘 형제들을 렌더해 **느린 구간을 예열(pre-warm)** 해요. 화면 체감이 더 좋아졌어요. ([React](https://react.dev/blog/2024/04/25/react-19-upgrade-guide))

### React의 렌더링이 일어나는 조건을 한 번에 정리
- **리렌더 트리거**
    1. 내 `setState` 호출, 2) 부모 리렌더 → 새 props 전달, 3) 구독한 `Context` 변경, 4) 내 `key` 변경(=언마운트/마운트)예요.
- **렌더링 ≠ 실제 DOM 변경**
    - 렌더링 단계에서 **새 설계도(VDOM)** 를 만들고, **Diff 결과가 있을 때만 DOM 패치**가 일어나요.
- **배칭(automatic batching)**
    - 이벤트 루프 안에서 여러 `setState`가 모이면 **한 번에 묶어** 렌더링해요(성능↑).
- **StrictMode(개발 전용)**
    - **개발 모드에서만 일부 동작을 두 번 호출**해 “이상 징후”를 빨리 찾게 도와줘요(실서비스에 영향 없어요).
    - React 19에선 StrictMode에서의 **`useMemo`/`useCallback` 이중 호출 시 메모 결과 재사용** 등 개선이 있었어요. ([React](https://react.dev/blog/2024/04/25/react-19-upgrade-guide))

### React 19 최신 버전에서 알아두면 좋은 변화들
- **Actions(폼 액션)**: 폼을 제출하면서 **함수 호출 흐름을 간결하게** 만들 수 있는 새로운 패턴을 제공해요.
- **새 훅과 DOM 개선**: 문서 메타데이터 관리, 웹 컴포넌트 호환, 에셋 로딩, 뷰 전환 API 연동 등이 강화됐어요.
- **`ref`를 일반 prop처럼 전달**할 수 있게 바뀌었어요(새 JSX 트랜스폼 필요). 기존 `element.ref` 접근은 더는 권장되지 않아요. ([React](https://react.dev/blog/2024/12/05/react-19))
- **Suspense 동작 개선**: 위에서 설명했듯 **fallback을 더 빨리** 보여줘요. ([React](https://react.dev/blog/2024/04/25/react-19-upgrade-guide))
- **UMD 빌드 제거**: `<script>`로 쓸 땐 ESM CDN을 권장해요. ([React](https://react.dev/blog/2024/04/25/react-19-upgrade-guide))

> 더 자세한 목록은 React 19 릴리스/업그레이드 가이드에 표로 잘 정리돼 있어요. (React)

### “리액트가 일하는 순서” 이해
1. **상태/props 변경 감지** →
2. **렌더 단계**: 함수형 컴포넌트를 실행해 **새 JSX(=VDOM 설계도)** 생성 →
3. **비교 단계**: 이전 VDOM과 **Diff** →
4. **커밋 단계**: 바뀐 곳만 **실제 DOM 패치** & 브라우저 페인트 →
5. **효과 실행**: `useEffect`/`useLayoutEffect` 정리 → 재실행 순서로 동작해요.

이 흐름만 잡혀 있어도, “왜 지금 화면이 안 바뀌지?”, “왜 두 번 호출되지?” 같은 상황을 **원인-대응**으로 빠르게 추적할 수 있어요.

### 실전 팁 몇 가지
- **리스트엔 안정적인 `key`** 를 써요(id 권장). 인덱스 key는 삽입/삭제에서 꼬일 수 있어요.
- **이벤트 핸들러**는 가급적 **컴포넌트 바깥(혹은 `useCallback`)** 에서 정의해 **불필요한 재생성**을 줄여요.
- **상태는 최소화**해요. 계산 가능하면 `useMemo`로 파생해 쓰고, 원본만 상태로 두는 게 좋아요.
- **느린 업데이트**는 `startTransition`으로 표시해 **입력 반응성**을 지켜요.
- **개발 모드 StrictMode의 이중 호출**은 버그를 찾기 위한 “일부러 흔들기”예요. 당황하지 말고 **부작용 코드**(예: 렌더 중 setState, 외부 변이)를 점검해요.

### React 프로젝트는 **파일을 어떻게 나누느냐**에 따라 협업 효율과 유지보수성이 크게 달라져요.
아래는 많은 프로젝트에서 참고하는 기본 구조에요.

```
src/
 ┣ assets/
 ┣ components/
 ┣ pages/
 ┣ hooks/
 ┣ context/
 ┣ utils/
 ┣ types/
 ┣ apis/
 ┣ App.tsx
 ┗ main.tsx
```
**하지만!** 폴더 구조에는 정답이 없다 그러니 소통을 하며 최대한 컨벤션을 맞춰가는 것이 중요합니다!

<br/>

JSX